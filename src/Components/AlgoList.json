[
    {
      "title": "Tower of Hanoi",
      "category": "Recursion",
      "description": "There are three towers. The objective of the game is to move all the disks over to tower #3, but you can't place a larger disk onto a smaller disk.",
      "timeComplexity": "O(2‚Åø)",
      "spaceComplexity": "O(n)",
      "tags": ["algorithm", "maths", "numbers", "recursion"]
    },
    {
      "title": "Binary Search",
      "category": "Searching",
      "description": "A search algorithm that finds the position of a target value within a sorted array.",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "tags": ["array", "searching", "divide-and-conquer"]
    },
    {
      "title": "Find Duplicates",
      "category": "Searching",
      "description": "Find all duplicate numbers in an array using constant extra space.",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["array", "hash", "space optimization"]
    },
    {
      "title": "Merge Sort",
      "category": "Sorting",
      "description": "A divide-and-conquer sorting algorithm that recursively divides the array and merges sorted subarrays.",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "tags": ["array", "sorting", "divide-and-conquer", "recursion"]
    },
    {
      "title": "Quick Sort",
      "category": "Sorting",
      "description": "A highly efficient sorting algorithm using divide-and-conquer strategy with a pivot element.",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(log n)",
      "tags": ["array", "sorting", "divide-and-conquer", "partition"]
    },
    {
      "title": "Kadane's Algorithm",
      "category": "Dynamic",
      "description": "Find the maximum sum of a contiguous subarray within a one-dimensional array.",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "tags": ["array", "dynamic-programming", "optimization"]
    },
    {
      "title": "Dijkstra's Algorithm",
      "category": "Graph",
      "description": "Algorithm for finding the shortest paths between nodes in a graph with non-negative edge weights.",
      "timeComplexity": "O(E log V)",
      "spaceComplexity": "O(V + E)",
      "tags": ["graph", "shortest-path", "greedy"]
    }
  ]